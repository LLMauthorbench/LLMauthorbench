 # I Know Which LLM Wrote Your Code Last Summer:  LLM generated Code Stylometry for Authorship Attribution

## Description

**LLM-AuthorBench** is a benchmark for authorship attribution of C code generated by large language models (LLMs). As LLM-generated code becomes more common in production and open-source settings, identifying which model produced a given snippet is increasingly important.

This repository provides a dataset of 32,000 compilable C programs generated by eight state-of-the-art LLMs across diverse programming tasks.
The Google Colab code for training and evaluating both traditional ML classifiers and fine-tuned transformer models (e.g., BERT, CodeBERT, Longformer, and LoRA-adapted Qwen2-1.5B) is available in this repository to support further research.

Key results:

**97% accuracy** distinguishing GPT-4.1 vs GPT-4o (DeBERTa-v3, binary classification).

**95% accuracy in 5-way attribution** across Gemini 2.5-Flash, Claude 3.5, GPT-4.1, Llama 3.1, and Deepseek-V3.

 
 ## Framework


<img width="1636" alt="Framework" src="https://github.com/user-attachments/assets/29be292e-d709-4b1d-9e1c-af88d7e5d489" />




## Dataset

### 1. Dataset creation module

-   **Description:** This Google Colab script uses openrouter.ai to generate C code samples from various large language models (LLMs).
-  **Purpose:** To create a diverse dataset of automatically generated C code for further evaluation and benchmarking.
- **Script:** [1_DATASET_CREATOR_google_colab.ipynb](https://github.com/LLMauthorbench/LLMauthorbench/blob/main/scripts/1_DATASET_CREATOR_google_colab.ipynb)
 
 
 ### 2. Validate the compilability of the generated C code

- **Description:** This Google Colab script verifies that all C code entries in the dataset are compilable by using `gcc -c`. It checks each code sample for syntax errors, type errors, and translation unit correctness, but does not perform linking. In other words, the script assesses the compilability of the dataset's C code, ensuring each file is valid C source code, even though external references may remain unresolved.
- **Purpose:** To ensure that all generated C code samples are valid and compilable as C source files, regardless of external references.
- **Script:** [2_CHECK_COMPILABILITY_google_colab.ipynb](https://github.com/LLMauthorbench/LLMauthorbench/blob/main/scripts/2_CHECK_COMPILABILITY_google_colab.ipynb)

The LLM-AuthorBench dataset includes 32,000 compilable C programs. You can download the dataset from the following link:
[⬇️ Download LLM-AuthorBench.json.zip](https://github.com/LLMauthorbench/LLMauthorbench/raw/main/LLM-AuthorBench.json.zip)

 ### 3. Train and Evaluate BERT for LLM Authorship Attribution


- **Description:** This Google Colab script provides an end-to-end pipeline for training a BERT model on the LLM-AuthorBench dataset for authorship attribution tasks. It covers data preprocessing, model training, and evaluation, enabling users to assess the ability of BERT to identify the authorship of generated texts.
- **Purpose:** To benchmark BERT’s performance on LLM authorship attribution, facilitating research into identifying the origins of AI-generated content.
- **Script:**:  [3_BERT_training-5-class_google_colab.ipynb](https://github.com/LLMauthorbench/LLMauthorbench/blob/main/scripts/3_BERT_training-5-class_google_colab.ipynb)



For example, in a 5-class authorship attribution task, the confusion matrix for BERT—covering the following models: **Gemini 2.5 Flash, Claude 3.5 Haiku, GPT-4.1, Llama 3.1, and DeepSeek-V3**—can be seen below:

![image](https://github.com/user-attachments/assets/baa2b0dc-b884-479d-a9db-6c5420c7cfb1)


Sample Entry from the JSON File:

```python
{
  "model_name": "gpt-4o",
  "prompt": "Generate a C program that implements AVL tree insertion for 92 elements.",
  "c_code": "#include <stdio.h>\\n#include <stdlib.h>\\n\\n// Define the structure for AVL tree node\\ntypedef struct Node {\\n    int key;\\n    struct Node *left;\\n    struct Node *right;\\n    int height;\\n} Node;\\n\\n// Function to get the height of the tree\\nint height(Node *N) {\\n    if (N == NULL)\\n        return 0;\\n    return N->height;\\n}\\n\\n// Function to create a new node\\nNode *newNode(int key) {\\n    Node *node = (Node *)malloc(sizeof(Node));\\n    node->key = key;\\n    node->left = NULL;\\n    node->right = NULL;\\n    node->height = 1;  // New node is added at leaf\\n    return node;\\n}\\n\\n// Function to right rotate subtree rooted with y\\nNode *rightRotate(Node *y) {\\n    Node *x = y->left;\\n    Node *T2 = x->right;\\n    \\n    // Perform rotation\\n    x->right = y;\\n    y->left = T2;\\n\\n    // Update heights\\n    y->height = max(height(y->left), height(y->right)) + 1;\\n    x->height = max(height(x->left), height(x->right)) + 1;\\n\\n    // Return new root\\n    return x;\\n}\\n\\n// Function to left rotate subtree rooted with x\\nNode *leftRotate(Node *x) {\\n    Node *y = x->right;\\n    Node *T2 = y->left;\\n    \\n    // Perform rotation\\n    y->left = x;\\n    x->right = T2;\\n    \\n    // Update heights\\n    x->height = max(height(x->left), height(x->right)) + 1;\\n    y->height = max(height(y->left), height(y->right)) + 1;\\n    \\n    // Return new root\\n    return y;\\n}\\n\\n// Get balance factor of node N\\nint getBalance(Node *N) {\\n    if (N == NULL)\\n        return 0;\\n    return height(N->left) - height(N->right);\\n}\\n\\n// Utility function to get the maximum of two integers\\nint max(int a, int b) {\\n    return (a > b) ? a : b;\\n}\\n\\n// Function to insert a key in the subtree rooted with node and returns the new root of the subtree\\nNode *insert(Node *node, int key) {\\n    // Perform the normal BST insertion\\n    if (node == NULL)\\n        return newNode(key);\\n\\n    if (key < node->key)\\n        node->left = insert(node->left, key);\\n    else if (key > node->key)\\n        node->right = insert(node->right, key);\\n    else  // Equal keys are not allowed in AVL tree\\n        return node;\\n\\n    // Update height of this ancestor node\\n    node->height = 1 + max(height(node->left), height(node->right));\\n\\n    // Get the balance factor of this ancestor node to check whether this node became unbalanced\\n    int balance = getBalance(node);\\n\\n    // If this node becomes unbalanced, then there are 4 cases\\n\\n    // Left Left Case\\n    if (balance > 1 && key < node->left->key)\\n        return rightRotate(node);\\n\\n    // Right Right Case\\n    if (balance < -1 && key > node->right->key)\\n        return leftRotate(node);\\n\\n    // Left Right Case\\n    if (balance > 1 && key > node->left->key) {\\n        node->left = leftRotate(node->left);\\n        return rightRotate(node);\\n    }\\n\\n    // Right Left Case\\n    if (balance < -1 && key < node->right->key) {\\n        node->right = rightRotate(node->right);\\n        return leftRotate(node);\\n    }\\n\\n    // Return the (unchanged) node pointer\\n    return node;\\n}\\n\\n// Function to print preorder traversal of the tree\\nvoid preOrder(Node *root) {\\n    if (root != NULL) {\\n        printf(\\\"%d \\\", root->key);\\n        preOrder(root->left);\\n        preOrder(root->right);\\n    }\\n}\\n\\n// Driver program to test above functions\\nint main() {\\n    Node *root = NULL;\\n\\n    // Sample input of 92 unique elements\\n    int elements[92] = {15, 30, 40, 42, 50, 55, 60, 65, 70, 72, 75, 80, 85, 90, 92, 95, 99, 100,\\n                        105, 110, 115, 120, 125, 130, 135, 140, 145, 150, 155, 160, 165, 170, 175,\\n                        180, 185, 190, 195, 200, 205, 210, 215, 220, 225, 230, 235, 240, 245, 250,\\n                        255, 260, 265, 270, 275, 280, 285, 290, 295, 300, 305, 310, 315, 320, 325,\\n                        330, 335, 340, 345, 350, 355, 360, 365, 370, 375, 380, 385, 390, 395, 400,\\n                        405, 410, 415, 420, 425, 430, 435, 440, 445, 450, 455, 460, 465, 470};\\n\\n    for (int i = 0; i < 92; i++) {\\n        root = insert(root, elements[i]);\\n    }\\n\\n    printf(\\\"Preorder traversal of the constructed AVL tree is \\\\n\\\");\\n    preOrder(root);\\n\\n    return 0;\\n}",
  "SHA256_checksum": "00028bc41160952a49879a71d857b6fa31b4c45a036efce6ae6c280315edeb01",
  "char_count": 4031,
  "num_lines": 149
}
```
